import asyncio
import time
from typing import Any, Dict, List, Optional, Tuple

from fastapi import FastAPI, Query, Header, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from app.state import STATE
from app.feeds.lighter_markets import fetch_lighter_markets
from app.feeds.lighter_ws import lighter_ws_loop, STATE as LIGHTER_WS_STATE


app = FastAPI(title="Var-Lighter SpreadWatch (Browser Ingest)")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # local dashboard
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ----------------------------
# Var quotes store (pushed from browser)
# VAR_QUOTES[base][notional][side] = (price, ts_ms)
# ----------------------------
VAR_QUOTES: Dict[str, Dict[float, Dict[str, Tuple[float, int]]]] = {}
VAR_TTL_MS = 60_000


def _now_ms() -> int:
    return int(time.time() * 1000)


def _safe_int(x) -> Optional[int]:
    try:
        if x is None:
            return None
        return int(x)
    except Exception:
        return None


def _get_var_price(base: str, notional: float, side: str) -> Optional[float]:
    base = base.upper().strip()
    side = side.lower().strip()
    by_notional = VAR_QUOTES.get(base)
    if not by_notional:
        return None
    by_side = by_notional.get(float(notional))
    if not by_side:
        return None
    v = by_side.get(side)
    if not v:
        return None
    price, ts = v
    if _now_ms() - ts > VAR_TTL_MS:
        return None
    return price


def _compute_spread(
    lighter_best_bid: Optional[float],
    lighter_best_ask: Optional[float],
    var_buy: Optional[float],
    var_sell: Optional[float],
    mode: str,
) -> Dict[str, Optional[float]]:
    """
    mode:
      - "lighter_bid_minus_var_sell" (DEFAULT, user habit)
      - "var_buy_minus_lighter_ask"  (old)
    """
    mode = (mode or "").strip()

    if mode == "var_buy_minus_lighter_ask":
        if var_buy is None or lighter_best_ask is None or lighter_best_ask == 0:
            return {"spread_usd": None, "spread_bps": None}
        spread = var_buy - lighter_best_ask
        bps = spread / lighter_best_ask * 10000.0
        return {"spread_usd": spread, "spread_bps": bps}

    # default: lighter_bid - var_sell
    if var_sell is None or lighter_best_bid is None or var_sell == 0:
        return {"spread_usd": None, "spread_bps": None}
    spread = lighter_best_bid - var_sell
    bps = spread / var_sell * 10000.0
    return {"spread_usd": spread, "spread_bps": bps}


class VarQuoteIn(BaseModel):
    base: str
    notional_usd: float
    side: Optional[str] = "buy"   # "buy" or "sell"
    price: float
    ts_ms: Optional[int] = None
    source: Optional[str] = "tampermonkey"


@app.on_event("startup")
async def on_startup():
    if not hasattr(STATE, "markets") or STATE.markets is None:
        STATE.markets = {}

    # load lighter markets list (symbol -> market_id)
    try:
        markets = await fetch_lighter_markets()
        print(f"[BOOT] fetched lighter markets: {len(markets)}")

        for row in markets:
            base = str(row.get("symbol", "")).upper().strip()
            mid = _safe_int(row.get("market_index") if "market_index" in row else row.get("market_id"))
            if not base or mid is None:
                continue

            if base not in STATE.markets:
                try:
                    STATE.add_market(base=base, market_id=mid)  # optional
                except Exception:
                    STATE.markets[base] = {"base": base, "market_id": mid}

            try:
                STATE.markets[base].market_id = mid  # type: ignore
            except Exception:
                try:
                    STATE.markets[base]["market_id"] = mid  # type: ignore
                except Exception:
                    pass

    except Exception as e:
        print(f"[BOOT] WARNING: fetch_lighter_markets failed, continue startup. err={repr(e)}")

    # start lighter ws
    app.state.lighter_stop = asyncio.Event()
    app.state.lighter_task = asyncio.create_task(lighter_ws_loop(app.state.lighter_stop))


@app.on_event("shutdown")
async def on_shutdown():
    try:
        app.state.lighter_stop.set()
    except Exception:
        pass
    try:
        await asyncio.wait_for(app.state.lighter_task, timeout=10)
    except Exception:
        pass


@app.get("/health")
async def health():
    markets_count = 0
    try:
        markets_count = len(getattr(STATE, "markets", {}) or {})
    except Exception:
        markets_count = 0

    lighter_tick_ms, lighter_err, lighter_sid, lighter_by_mid = await LIGHTER_WS_STATE.snapshot()

    return {
        "ok": True,
        "tick_ms": lighter_tick_ms,
        "markets": markets_count,
        "var_quotes_bases": len(VAR_QUOTES),
        "lighter_session_id": lighter_sid,
        "lighter_markets_seen": len(lighter_by_mid),
        "lighter_last_error": lighter_err,
    }


@app.post("/ingest/var")
async def ingest_var_quote(
    q: VarQuoteIn,
    x_var_ingest_token: Optional[str] = Header(default=None),
):
    expected = None
    # import os
    # expected = os.getenv("VAR_INGEST_TOKEN")

    if expected and x_var_ingest_token != expected:
        raise HTTPException(status_code=401, detail="bad token")

    base = q.base.upper().strip()
    notional = float(q.notional_usd)
    side = (q.side or "buy").lower().strip()
    price = float(q.price)
    ts = int(q.ts_ms) if q.ts_ms is not None else _now_ms()

    if base == "" or notional <= 0 or price <= 0:
        return {"ok": True}

    by_notional = VAR_QUOTES.setdefault(base, {})
    by_side = by_notional.setdefault(notional, {})
    by_side[side] = (price, ts)

    return {"ok": True}


@app.get("/api/markets")
async def api_markets(
    notional: float = Query(1500.0),
    spread_mode: str = Query("lighter_bid_minus_var_sell"),
):
    """
    spread_mode:
      - lighter_bid_minus_var_sell (DEFAULT)
      - var_buy_minus_lighter_ask
    """
    out: List[Dict[str, Any]] = []
    markets = getattr(STATE, "markets", {}) or {}

    lighter_tick_ms, lighter_err, lighter_sid, lighter_by_mid = await LIGHTER_WS_STATE.snapshot()

    for base, m in markets.items():
        if isinstance(m, dict):
            market_id = _safe_int(m.get("market_id"))
        else:
            market_id = _safe_int(getattr(m, "market_id", None))

        t = lighter_by_mid.get(market_id) if market_id is not None else None

        lighter_best_ask = getattr(t, "best_ask", None) if t else None
        lighter_best_bid = getattr(t, "best_bid", None) if t else None
        lighter_vol = getattr(t, "daily_quote_volume", None) if t else None
        lighter_mark = getattr(t, "mark_price", None) if t else None

        var_buy = _get_var_price(str(base), float(notional), "buy")
        var_sell = _get_var_price(str(base), float(notional), "sell")

        spread = _compute_spread(
            lighter_best_bid=lighter_best_bid,
            lighter_best_ask=lighter_best_ask,
            var_buy=var_buy,
            var_sell=var_sell,
            mode=spread_mode,
        )

        out.append({
            "base": str(base),
            "lighter_market_id": market_id,
            "lighter_best_ask": lighter_best_ask,
            "lighter_best_bid": lighter_best_bid,
            "lighter_mark_price": lighter_mark,
            "lighter_daily_quote_volume": lighter_vol,
            "var_buy_notional": var_buy,
            "var_sell_notional": var_sell,
            "spread_mode": spread_mode,
            "spread_usd": spread["spread_usd"],
            "spread_bps": spread["spread_bps"],
        })

    def _sort_key(x: Dict[str, Any]):
        vol = x.get("lighter_daily_quote_volume")
        vol = vol if isinstance(vol, (int, float)) else -1
        bps = x.get("spread_bps")
        abps = abs(bps) if isinstance(bps, (int, float)) else -1
        return (vol, abps)

    out.sort(key=_sort_key, reverse=True)
    return out
