import asyncio
import time
from typing import Any, Dict, List, Optional

from fastapi import FastAPI, Query
from fastapi.middleware.cors import CORSMiddleware

from app.state import STATE
from app.feeds.lighter_markets import fetch_lighter_markets
from app.feeds.lighter_ws import lighter_ws_loop
from app.feeds.var_playwright import var_poll_loop, var_debug_once


app = FastAPI(title="Var-Lighter SpreadWatch")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


def _safe_float(x) -> Optional[float]:
    try:
        if x is None:
            return None
        return float(x)
    except Exception:
        return None


def _safe_int(x) -> Optional[int]:
    try:
        if x is None:
            return None
        return int(x)
    except Exception:
        return None


def _compute_spread(var_buy: Optional[float], lighter_best_ask: Optional[float]) -> Dict[str, Optional[float]]:
    if var_buy is None or lighter_best_ask is None:
        return {"spread_usd": None, "spread_bps": None}
    spread = var_buy - lighter_best_ask
    if lighter_best_ask == 0:
        return {"spread_usd": spread, "spread_bps": None}
    bps = spread / lighter_best_ask * 10000.0
    return {"spread_usd": spread, "spread_bps": bps}


@app.on_event("startup")
async def on_startup():
    # Ensure STATE.markets exists
    if not hasattr(STATE, "markets") or STATE.markets is None:
        STATE.markets = {}

    # 关键改动：markets 拉不到也不让服务启动失败
    markets: List[Dict[str, Any]] = []
    try:
        markets = await fetch_lighter_markets()
        print(f"[BOOT] fetched lighter markets: {len(markets)}")
    except Exception as e:
        print(f"[BOOT] WARNING: fetch_lighter_markets failed, continue startup. err={repr(e)}")
        markets = []

    # Build/attach market ids if we have them
    for row in markets:
        base = str(row.get("symbol", "")).upper().strip()
        mid = _safe_int(row.get("market_id"))
        if not base or mid is None:
            continue

        if base not in STATE.markets:
            # If STATE has helper use it, otherwise store minimal dict
            try:
                STATE.add_market(base=base, market_id=mid)  # optional
            except Exception:
                STATE.markets[base] = {"base": base, "market_id": mid}

        # attach market_id
        try:
            STATE.markets[base].market_id = mid  # type: ignore
        except Exception:
            try:
                STATE.markets[base]["market_id"] = mid  # type: ignore
            except Exception:
                pass

    # Start loops even if markets list is empty; Lighter WS may still fill later
    app.state.lighter_stop = asyncio.Event()
    app.state.lighter_task = asyncio.create_task(lighter_ws_loop(app.state.lighter_stop))

    app.state.var_stop = asyncio.Event()
    app.state.var_task = asyncio.create_task(var_poll_loop(app.state.var_stop))


@app.on_event("shutdown")
async def on_shutdown():
    try:
        app.state.lighter_stop.set()
    except Exception:
        pass
    try:
        app.state.var_stop.set()
    except Exception:
        pass

    try:
        await asyncio.wait_for(app.state.lighter_task, timeout=10)
    except Exception:
        pass
    try:
        await asyncio.wait_for(app.state.var_task, timeout=20)
    except Exception:
        pass


@app.get("/health")
async def health():
    markets_count = 0
    try:
        markets_count = len(getattr(STATE, "markets", {}) or {})
    except Exception:
        markets_count = 0

    return {"ok": True, "tick_ms": getattr(STATE, "last_tick_ms", 0), "markets": markets_count}


@app.get("/api/markets")
async def api_markets():
    out: List[Dict[str, Any]] = []
    markets = getattr(STATE, "markets", {}) or {}

    for base, m in markets.items():
        if isinstance(m, dict):
            market_id = _safe_int(m.get("market_id"))
            lighter_best_ask = None
            lighter_best_bid = None
            lighter_vol = None
            var_buy_1500 = None
            var_buy_confirm = None
        else:
            market_id = _safe_int(getattr(m, "market_id", None))

            book = getattr(m, "book", None)
            lighter_best_ask = _safe_float(getattr(book, "best_ask", None)) if book else None
            lighter_best_bid = _safe_float(getattr(book, "best_bid", None)) if book else None

            stats = getattr(m, "stats", None)
            lighter_vol = _safe_float(getattr(stats, "daily_quote_volume", None)) if stats else None

            var = getattr(m, "var", None)
            var_buy_1500 = _safe_float(getattr(var, "buy_1500", None)) if var else None
            var_buy_confirm = _safe_float(getattr(var, "buy_confirm", None)) if var else None

        spread = _compute_spread(var_buy_1500, lighter_best_ask)

        out.append({
            "base": str(base),
            "lighter_market_id": market_id,
            "lighter_best_ask": lighter_best_ask,
            "lighter_best_bid": lighter_best_bid,
            "lighter_daily_quote_volume": lighter_vol,
            "var_buy_1500": var_buy_1500,
            "var_buy_confirm": var_buy_confirm,
            "spread_usd": spread["spread_usd"],
            "spread_bps": spread["spread_bps"],
        })

    # sort by volume desc
    def _sort_key(x: Dict[str, Any]):
        vol = x.get("lighter_daily_quote_volume")
        vol = vol if isinstance(vol, (int, float)) else -1
        return vol

    out.sort(key=_sort_key, reverse=True)
    return out


@app.get("/debug/var_once")
async def debug_var_once(
    base: str = Query("BTC"),
    usd: float = Query(1500.0),
    screenshot: bool = Query(True),
):
    return await var_debug_once(base.upper(), float(usd), take_screenshot=bool(screenshot))
